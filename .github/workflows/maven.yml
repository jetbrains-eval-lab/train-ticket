name: Run Tests

on:
  push:
    branches: [ "main", "scenario/*", "eval/*", "feature/*" ]
  pull_request:
    branches: [ "main", "scenario/*", "eval/*", "feature/*" ]
  issue_comment:
    types: [created]

jobs:
  # ──────────── 1. collect and process tests ────────────
  collect-process-tests:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      fail_to_pass: ${{ steps.combine.outputs.fail_to_pass }}
      pass_to_pass: ${{ steps.combine.outputs.pass_to_pass }}
      tests: ${{ steps.combine.outputs.tests }}
      comment_id: ${{ steps.combine.outputs.comment_id }}
      test_args: ${{ steps.combine.outputs.test_args }}
      java_version: ${{ steps.combine.outputs.java_version }}
    if: ${{ github.event_name != 'issue_comment' || contains(github.event.comment.body, 'FAIL_TO_PASS') || contains(github.event.comment.body, 'PASS_TO_PASS') }}
    steps:
      - uses: actions/checkout@v4

      # ─── 1.1 collect issue numbers based on event type ───
      - name: Collect issue numbers based on event type
        id: collect_issues
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          REPO: ${{ github.repository }}
        run: |
          # Initialize issue numbers variable
          ISSUE_NUMBERS=""
          
          # Handle different event types
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            echo "Collecting issue numbers from commits in PR #$PR_NUMBER"
          
            # Get all commits in the PR
            COMMITS=$(gh api repos/$REPO/pulls/$PR_NUMBER/commits --jq '.[].sha')
          
            # Initialize an empty array for issue numbers
            ISSUE_NUMBERS_ARRAY=()
          
            # For each commit, extract linked issue numbers
            for COMMIT in $COMMITS; do
              echo "Processing commit $COMMIT"
          
              # Get commit message
              COMMIT_MSG=$(gh api repos/$REPO/commits/$COMMIT --jq '.commit.message')
          
              # Extract issue numbers using regex (e.g., #123, fixes #456, etc.)
              ISSUES=$(echo "$COMMIT_MSG" | grep -o '#[0-9]\+' | sed 's/#//')
          
              if [ -n "$ISSUES" ]; then
                echo "Found issues in commit $COMMIT: $ISSUES"
                # Add to our array
                for ISSUE in $ISSUES; do
                  ISSUE_NUMBERS_ARRAY+=("$ISSUE")
                done
              fi
            done
          
            # Remove duplicates and create JSON array
            UNIQUE_ISSUES=$(echo "${ISSUE_NUMBERS_ARRAY[@]}" | tr ' ' '\n' | sort -u)
          
            if [ -z "$UNIQUE_ISSUES" ]; then
              echo "No issue numbers found in commit messages, using PR number as fallback"
              ISSUE_NUMBERS="[\"${{ github.event.pull_request.number }}\"]"
            else
              # Convert to JSON array
              ISSUE_NUMBERS=$(echo "$UNIQUE_ISSUES" | jq -R . | jq -s .)
            fi
          elif [[ "${{ github.event_name }}" == "push" ]]; then
            echo "Extracting issue numbers from commit message"
          
            # Get commit message
            COMMIT_MSG="${{ github.event.head_commit.message }}"
          
            # Extract issue numbers using regex (e.g., #123, fixes #456, etc.)
            ISSUES=$(echo "$COMMIT_MSG" | grep -o '#[0-9]\+' | sed 's/#//')
          
            if [ -n "$ISSUES" ]; then
              echo "Found issues in commit message: $ISSUES"
          
              # Initialize an empty array for issue numbers
              ISSUE_NUMBERS_ARRAY=()
          
              # Add to our array
              for ISSUE in $ISSUES; do
                ISSUE_NUMBERS_ARRAY+=("$ISSUE")
              done
          
              # Remove duplicates and create JSON array
              UNIQUE_ISSUES=$(echo "${ISSUE_NUMBERS_ARRAY[@]}" | tr ' ' '\n' | sort -u)
          
              # Convert to JSON array
              ISSUE_NUMBERS=$(echo "$UNIQUE_ISSUES" | jq -R . | jq -s .)
            else
              echo "No issue numbers found in commit message, using empty array as fallback"
              ISSUE_NUMBERS="[\"\"]"
            fi
          elif [[ "${{ github.event_name }}" == "issue_comment" ]]; then
            echo "Using issue number from comment event"
            ISSUE_NUMBERS="[\"${{ github.event.issue.number }}\"]"
          else
            echo "Using fallback issue number from inputs"
            ISSUE_NUMBERS="[\"\"]"
          fi
          
          echo "Found issue numbers: $ISSUE_NUMBERS"
          # Escape the JSON string for GitHub Actions output
          ESCAPED_ISSUE_NUMBERS=$(echo "$ISSUE_NUMBERS" | jq -c .)
          echo "issue_numbers=$ESCAPED_ISSUE_NUMBERS" >> $GITHUB_OUTPUT

      # ─── 1.2 extract test names from issues ───
      - name: Extract test names for issues
        id: extract_tests
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBERS: ${{ steps.collect_issues.outputs.issue_numbers }}
          REPO: ${{ github.repository }}
        run: |
          # Initialize arrays for test results
          FAIL_TO_PASS=()
          PASS_TO_PASS=()
          TESTS=()
          COMMENT_ID=""
          
          # Process each issue number
          for ISSUE_NUMBER in $(echo $ISSUE_NUMBERS | jq -r '.[]'); do
            if [[ -z "$ISSUE_NUMBER" || "$ISSUE_NUMBER" == "null" ]]; then
              continue
            fi
          
            echo "Processing issue #$ISSUE_NUMBER"
          
            # Function to extract FAIL_TO_PASS and PASS_TO_PASS from text
            extract_test_fields() {
              local text="$1"
              local fail_to_pass=""
              local pass_to_pass=""
          
              if [[ -n "$text" ]]; then
                # Find FAIL_TO_PASS pattern
                if [[ "$text" =~ FAIL_TO_PASS:[[:space:]]*([^$'\n']+) ]]; then
                  fail_to_pass="${BASH_REMATCH[1]}"
                fi
          
                # Find PASS_TO_PASS pattern
                if [[ "$text" =~ PASS_TO_PASS:[[:space:]]*([^$'\n']+) ]]; then
                  pass_to_pass="${BASH_REMATCH[1]}"
                fi
              fi
          
              echo "$fail_to_pass|$pass_to_pass"
            }
          
            # First check issue comments
            echo "Checking issue comments for test fields..."
            COMMENTS=$(gh api repos/$REPO/issues/$ISSUE_NUMBER/comments --jq '.[] | {id: .id, body: .body, created_at: .created_at}')
          
            if [[ -n "$COMMENTS" ]]; then
              # Process all comments to find the latest one with FAIL_TO_PASS or PASS_TO_PASS
              LATEST_COMMENT_WITH_VALUES=""
              LATEST_COMMENT_ID=""
              LATEST_FAIL_TO_PASS=""
              LATEST_PASS_TO_PASS=""
          
              while IFS= read -r COMMENT; do
                COMMENT_BODY=$(echo "$COMMENT" | jq -r '.body')
                CURRENT_COMMENT_ID=$(echo "$COMMENT" | jq -r '.id')
          
                RESULT=$(extract_test_fields "$COMMENT_BODY")
                IFS='|' read -r COMMENT_FAIL COMMENT_PASS <<< "$RESULT"
          
                if [[ -n "$COMMENT_FAIL" || -n "$COMMENT_PASS" ]]; then
                  LATEST_COMMENT_WITH_VALUES="$COMMENT"
                  LATEST_COMMENT_ID="$CURRENT_COMMENT_ID"
          
                  if [[ -n "$COMMENT_FAIL" ]]; then
                    LATEST_FAIL_TO_PASS="$COMMENT_FAIL"
                    echo "Found FAIL_TO_PASS in issue comment $CURRENT_COMMENT_ID: $COMMENT_FAIL"
                  fi
          
                  if [[ -n "$COMMENT_PASS" ]]; then
                    LATEST_PASS_TO_PASS="$COMMENT_PASS"
                    echo "Found PASS_TO_PASS in issue comment $CURRENT_COMMENT_ID: $COMMENT_PASS"
                  fi
                fi
              done <<< "$COMMENTS"
          
              # Use values from the latest comment
              if [[ -n "$LATEST_COMMENT_WITH_VALUES" ]]; then
                COMMENT_ID="$LATEST_COMMENT_ID"
          
                if [[ -n "$LATEST_FAIL_TO_PASS" ]]; then
                  FAIL_TO_PASS=("$LATEST_FAIL_TO_PASS")
                  echo "Using FAIL_TO_PASS from latest comment $COMMENT_ID: $LATEST_FAIL_TO_PASS"
                fi
          
                if [[ -n "$LATEST_PASS_TO_PASS" ]]; then
                  PASS_TO_PASS=("$LATEST_PASS_TO_PASS")
                  echo "Using PASS_TO_PASS from latest comment $COMMENT_ID: $LATEST_PASS_TO_PASS"
                fi
              fi
            fi
          
            # If not found in comments, check commit messages
            if [[ ${#FAIL_TO_PASS[@]} -eq 0 && ${#PASS_TO_PASS[@]} -eq 0 ]]; then
              echo "Checking commit messages for test fields..."
          
              # Get linked commit IDs
              COMMIT_IDS=$(gh api repos/$REPO/issues/$ISSUE_NUMBER/timeline --jq '.[] | select(.event == "referenced" and .commit_id != null) | .commit_id')
          
              if [[ -z "$COMMIT_IDS" ]]; then
                echo "No directly linked commits found, checking PRs..."
          
                # Try to get commits from PRs
                PR_NUMBERS=$(gh api repos/$REPO/issues/$ISSUE_NUMBER/timeline --jq '.[] | select(.event == "cross-referenced" and .source.issue.pull_request != null) | .source.issue.number')
          
                if [[ -n "$PR_NUMBERS" ]]; then
                  for PR in $PR_NUMBERS; do
                    echo "Fetching commits from PR #$PR..."
                    PR_COMMITS=$(gh api repos/$REPO/pulls/$PR/commits --jq '.[].sha')
          
                    if [[ -n "$PR_COMMITS" ]]; then
                      COMMIT_IDS="$COMMIT_IDS"$'\n'"$PR_COMMITS"
                    fi
                  done
                fi
              fi
          
              # Process commit messages to find the latest one with FAIL_TO_PASS or PASS_TO_PASS
              if [[ -n "$COMMIT_IDS" ]]; then
                # Variables to track the latest commit with values
                LATEST_COMMIT_ID=""
                LATEST_COMMIT_DATE=""
                LATEST_COMMIT_FAIL=""
                LATEST_COMMIT_PASS=""
          
                while IFS= read -r COMMIT_ID; do
                  if [[ -z "$COMMIT_ID" ]]; then
                    continue
                  fi
          
                  echo "Fetching message for commit: $COMMIT_ID"
                  COMMIT_DATA=$(gh api repos/$REPO/commits/$COMMIT_ID --jq '{message: .commit.message, date: .commit.author.date}')
                  COMMIT_MSG=$(echo "$COMMIT_DATA" | jq -r '.message')
                  COMMIT_DATE=$(echo "$COMMIT_DATA" | jq -r '.date')
          
                  if [[ -n "$COMMIT_MSG" ]]; then
                    RESULT=$(extract_test_fields "$COMMIT_MSG")
                    IFS='|' read -r COMMIT_FAIL COMMIT_PASS <<< "$RESULT"
          
                    if [[ -n "$COMMIT_FAIL" || -n "$COMMIT_PASS" ]]; then
                      # Check if this commit is newer than our current latest
                      if [[ -z "$LATEST_COMMIT_DATE" || "$COMMIT_DATE" > "$LATEST_COMMIT_DATE" ]]; then
                        LATEST_COMMIT_ID="$COMMIT_ID"
                        LATEST_COMMIT_DATE="$COMMIT_DATE"
                        LATEST_COMMIT_FAIL="$COMMIT_FAIL"
                        LATEST_COMMIT_PASS="$COMMIT_PASS"
          
                        if [[ -n "$COMMIT_FAIL" ]]; then
                          echo "Found FAIL_TO_PASS in commit $COMMIT_ID: $COMMIT_FAIL"
                        fi
          
                        if [[ -n "$COMMIT_PASS" ]]; then
                          echo "Found PASS_TO_PASS in commit $COMMIT_ID: $COMMIT_PASS"
                        fi
                      fi
                    fi
                  fi
                done <<< "$COMMIT_IDS"
          
                # Use values from the latest commit
                if [[ -n "$LATEST_COMMIT_ID" ]]; then
                  if [[ -n "$LATEST_COMMIT_FAIL" ]]; then
                    FAIL_TO_PASS=("$LATEST_COMMIT_FAIL")
                    echo "Using FAIL_TO_PASS from latest commit $LATEST_COMMIT_ID: $LATEST_COMMIT_FAIL"
                  fi
          
                  if [[ -n "$LATEST_COMMIT_PASS" ]]; then
                    PASS_TO_PASS=("$LATEST_COMMIT_PASS")
                    echo "Using PASS_TO_PASS from latest commit $LATEST_COMMIT_ID: $LATEST_COMMIT_PASS"
                  fi
                fi
              fi
            fi
          done
          
          # Convert arrays to comma-separated strings
          FAIL_TO_PASS_STR=$(IFS=,; echo "${FAIL_TO_PASS[*]}")
          PASS_TO_PASS_STR=$(IFS=,; echo "${PASS_TO_PASS[*]}")
          
          # Convert to JSON arrays if not empty
          if [[ -n "$FAIL_TO_PASS_STR" ]]; then
            FAIL_TO_PASS_JSON=$(echo "$FAIL_TO_PASS_STR" | jq -R -c 'split(",") | map(select(length > 0))')
          else
            FAIL_TO_PASS_JSON="[]"
          fi

          if [[ -n "$PASS_TO_PASS_STR" ]]; then
            PASS_TO_PASS_JSON=$(echo "$PASS_TO_PASS_STR" | jq -R -c 'split(",") | map(select(length > 0))')
          else
            PASS_TO_PASS_JSON="[]"
          fi
          
          # Combine tests
          if [[ -n "$FAIL_TO_PASS_STR" || -n "$PASS_TO_PASS_STR" ]]; then
            TESTS_STR="$FAIL_TO_PASS_STR,$PASS_TO_PASS_STR"
            TESTS_STR=$(echo "$TESTS_STR" | sed 's/^,//;s/,$//')
          fi
          
          # Output results
          echo "fail_to_pass=$FAIL_TO_PASS_JSON" >> $GITHUB_OUTPUT
          echo "pass_to_pass=$PASS_TO_PASS_JSON" >> $GITHUB_OUTPUT
          echo "tests=$TESTS_STR" >> $GITHUB_OUTPUT
          echo "comment_id=$COMMENT_ID" >> $GITHUB_OUTPUT

      # ─── 1.3 extract metadata (optional) ───
      - name: Extract metadata fields
        id: extract_metadata
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBERS: ${{ steps.collect_issues.outputs.issue_numbers }}
          REPO: ${{ github.repository }}
        run: |
          set -e
          TEST_ARGS=""
          JAVA_VERSION=""

          parse_metadata() {
            local text="$1"
            local json
            if [[ -n "$text" && "$text" =~ METADATA:[[:space:]]*(\{.*\}) ]]; then
              json="${BASH_REMATCH[1]}"
              # Normalize quotes for jq if needed
              TA=$(echo "$json" | jq -r '."test_args" // empty' 2>/dev/null || true)
              JV=$(echo "$json" | jq -r '."java-version" // empty' 2>/dev/null || true)
              if [[ -n "$TA" ]]; then TEST_ARGS="$TA"; fi
              if [[ -n "$JV" ]]; then JAVA_VERSION="$JV"; fi
            fi
          }

          for ISSUE_NUMBER in $(echo $ISSUE_NUMBERS | jq -r '.[]'); do
            if [[ -z "$ISSUE_NUMBER" || "$ISSUE_NUMBER" == "null" ]]; then
              continue
            fi

            # Check issue comments (latest first)
            COMMENTS=$(gh api repos/$REPO/issues/$ISSUE_NUMBER/comments --jq '.[] | {id: .id, body: .body, created_at: .created_at}' || true)
            if [[ -n "$COMMENTS" ]]; then
              LATEST_COMMENT_WITH_VALUES=""
              while IFS= read -r COMMENT; do
                COMMENT_BODY=$(echo "$COMMENT" | jq -r '.body')
                if [[ -n "$COMMENT_BODY" ]]; then
                  parse_metadata "$COMMENT_BODY"
                fi
              done <<< "$COMMENTS"
            fi

            if [[ -z "$TEST_ARGS" && -z "$JAVA_VERSION" ]]; then
              # Scan linked commits
              COMMIT_IDS=$(gh api repos/$REPO/issues/$ISSUE_NUMBER/timeline --jq '.[] | select(.event == "referenced" and .commit_id != null) | .commit_id' || true)
              if [[ -z "$COMMIT_IDS" ]]; then
                PR_NUMBERS=$(gh api repos/$REPO/issues/$ISSUE_NUMBER/timeline --jq '.[] | select(.event == "cross-referenced" and .source.issue.pull_request != null) | .source.issue.number' || true)
                if [[ -n "$PR_NUMBERS" ]]; then
                  for PR in $PR_NUMBERS; do
                    PR_COMMITS=$(gh api repos/$REPO/pulls/$PR/commits --jq '.[].sha' || true)
                    [[ -n "$PR_COMMITS" ]] && COMMIT_IDS="$COMMIT_IDS"$'\n'"$PR_COMMITS"
                  done
                fi
              fi
              if [[ -n "$COMMIT_IDS" ]]; then
                while IFS= read -r COMMIT_ID; do
                  [[ -z "$COMMIT_ID" ]] && continue
                  COMMIT_MSG=$(gh api repos/$REPO/commits/$COMMIT_ID --jq '.commit.message' || true)
                  parse_metadata "$COMMIT_MSG"
                done <<< "$COMMIT_IDS"
              fi
            fi

            # Break after first issue with metadata found
            if [[ -n "$TEST_ARGS" || -n "$JAVA_VERSION" ]]; then
              break
            fi
          done

          echo "test_args=$TEST_ARGS" >> $GITHUB_OUTPUT
          echo "java_version=$JAVA_VERSION" >> $GITHUB_OUTPUT

      # ─── 1.4 combine test results ───
      - name: Combine test results
        id: combine
        shell: bash
        run: |
          # Just pass through the outputs from extract_tests
          echo "fail_to_pass=${{ steps.extract_tests.outputs.fail_to_pass }}" >> $GITHUB_OUTPUT
          echo "pass_to_pass=${{ steps.extract_tests.outputs.pass_to_pass }}" >> $GITHUB_OUTPUT
          echo "tests=${{ steps.extract_tests.outputs.tests }}" >> $GITHUB_OUTPUT
          echo "comment_id=${{ steps.extract_tests.outputs.comment_id }}" >> $GITHUB_OUTPUT
          echo "test_args=${{ steps.extract_metadata.outputs.test_args }}" >> $GITHUB_OUTPUT
          echo "java_version=${{ steps.extract_metadata.outputs.java_version }}" >> $GITHUB_OUTPUT

      # ─── 1.4 check if FAIL_TO_PASS or PASS_TO_PASS found ───
      - name: Check if FAIL_TO_PASS or PASS_TO_PASS found
        if: ${{ github.event_name == 'pull_request' && steps.combine.outputs.fail_to_pass == '[]' && steps.combine.outputs.pass_to_pass == '[]' }}
        shell: bash
        run: |
          echo "::error::FAIL_TO_PASS or PASS_TO_PASS not found in commit messages or issue comments, please add FAIL_TO_PASS or PASS_TO_PASS to issue comment"
          exit 1

  # ──────────── 2. Run tests and handle comments ────────────
  run-tests-and-comments:
    needs: collect-process-tests
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
    if: ${{ always() && (github.event_name != 'pull_request' || needs.collect-process-tests.outputs.fail_to_pass != '[]' || needs.collect-process-tests.outputs.pass_to_pass != '[]') }}
    outputs:
      comment_id: ${{ steps.create_comment.outputs.comment_id }}
      status: ${{ job.status }}
    steps:
      - uses: actions/checkout@v4

      # Step 1: Create placeholder comment
      - name: Create placeholder issue comment
        id: create_comment
        if: ${{ github.event_name == 'push' || github.event_name == 'issue_comment' }}
        uses: actions/github-script@v7
        env:
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          WORKFLOW_NAME: ${{ github.workflow }}
          FAIL_TO_PASS: ${{ needs.collect-process-tests.outputs.fail_to_pass }}
          PASS_TO_PASS: ${{ needs.collect-process-tests.outputs.pass_to_pass }}
          COMMENT_ID: ${{ needs.collect-process-tests.outputs.comment_id }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          result-encoding: string
          script: |
            const issuePat = /#(\d+)/g;
            let issueNum = null, m;
            
            // • PR context
            if (context.payload.pull_request) {
              const whole = `${context.payload.pull_request.title}\n${context.payload.pull_request.body}`;
              if ((m = issuePat.exec(whole)) !== null) issueNum = +m[1];
            }
            
            // • Push context
            if (!issueNum && context.payload.commits) {
              for (const c of context.payload.commits) {
                if ((m = issuePat.exec(c.message)) !== null) { issueNum = +m[1]; break; }
              }
            }
            
            // • Issue comment context
            if (!issueNum && context.payload.issue) {
              issueNum = context.payload.issue.number;
            }
            
            if (!issueNum) { core.info('No #issue reference found.'); return; }
            
            let bodyContent = '';

            if (!process.env.COMMENT_ID){
              if (process.env.FAIL_TO_PASS && process.env.FAIL_TO_PASS !== '[]') {
                // Parse JSON array and convert to comma-separated string
                core.info('FAIL_TO_PASS: '+process.env.FAIL_TO_PASS);
                const failToPassArray = JSON.parse(process.env.FAIL_TO_PASS);              
                const failToPassString = failToPassArray.join(', ');            
                bodyContent += `FAIL_TO_PASS: ${failToPassString}\n`;
              }
            
              if (process.env.PASS_TO_PASS && process.env.PASS_TO_PASS !== '[]') {
                // Parse JSON array and convert to comma-separated string
                const passToPassArray = JSON.parse(process.env.PASS_TO_PASS);
                const passToPassString = passToPassArray.join(', ');
                bodyContent += `PASS_TO_PASS: ${passToPassString}\n`;
              }
            }

            bodyContent += `\n⏳ **[${process.env.WORKFLOW_NAME}](${process.env.RUN_URL})** has **started**…`;

            // If we have an existing comment ID, update it instead of creating a new one
            if (false && process.env.COMMENT_ID) {
              try {
                // Get existing comment body
                const { data: existingComment } = await github.rest.issues.getComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: Number(process.env.COMMENT_ID)
                });

                // Append new content to existing body
                const updatedBody = existingComment.body + '\n' + bodyContent;

                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: Number(process.env.COMMENT_ID),
                  body: updatedBody
                });
                core.setOutput('comment_id', process.env.COMMENT_ID);
                return;
              } catch (error) {
                core.warning(`Failed to update comment ${process.env.COMMENT_ID}: ${error.message}`);
                // Fall through to create a new comment
              }
            }

            // Create a new comment
            const { data: comment } = await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNum,
              body: bodyContent
            });
            core.setOutput('comment_id', comment.id.toString());

      # Step 2: Prepare parameters for dataset verification
      - name: Prepare dataset verification parameters
        id: prepare_params
        shell: bash
        env:
          EVENT_NAME: ${{ github.event_name }}
          REPO: ${{ github.repository }}
          CT_TEST_ARGS: ${{ needs.collect-process-tests.outputs.test_args }}
          CT_JAVA_VERSION: ${{ needs.collect-process-tests.outputs.java_version }}
        run: |
          set -e
          # Determine base and head SHAs
          if [[ "$EVENT_NAME" == "pull_request" ]]; then
            BASE_SHA="${{ github.event.pull_request.base.sha }}"
            HEAD_SHA="${{ github.event.pull_request.head.sha }}"
            ISSUE_NUMBER="${{ github.event.pull_request.number }}"
          elif [[ "$EVENT_NAME" == "push" ]]; then
            BASE_SHA="${{ github.event.before }}"
            HEAD_SHA="${{ github.sha }}"
            ISSUE_NUMBER="$(echo "${{ github.event.head_commit.message }}" | grep -oE '#[0-9]+' | head -n1 | tr -d '#')"
          elif [[ "$EVENT_NAME" == "issue_comment" ]]; then
            BASE_SHA="$(git rev-parse HEAD~1 || echo "")"
            HEAD_SHA="${{ github.sha }}"
            ISSUE_NUMBER="${{ github.event.issue.number }}"
          else
            BASE_SHA="$(git rev-parse HEAD~1 || echo "")"
            HEAD_SHA="${{ github.sha }}"
            ISSUE_NUMBER=""
          fi
          echo "Base: $BASE_SHA"
          echo "Head: $HEAD_SHA"

          # Ensure we have history
          git fetch --prune --unshallow || true
          git fetch --all --tags || true

          # Generate patches
          PATCH_CONTENT="$(git diff $BASE_SHA $HEAD_SHA -- . ':(exclude)src/test*' || true)"
          TEST_PATCH_CONTENT="$(git diff $BASE_SHA $HEAD_SHA -- 'src/test*' || true)"

          # Derived parameters
          TEST_ARGS="${CT_TEST_ARGS}"
          JAVA_VERSION="${CT_JAVA_VERSION}"
          # Normalize nulls and set defaults
          if [[ "$TEST_ARGS" == "null" ]]; then TEST_ARGS=""; fi
          if [[ -z "$JAVA_VERSION" || "$JAVA_VERSION" == "null" ]]; then JAVA_VERSION="24"; fi
          OWNER="${{ github.repository_owner }}"
          REPO_NAME="${REPO#*/}"
          if [[ -n "$ISSUE_NUMBER" ]]; then
            INSTANCE_ID="${OWNER}__${REPO_NAME}__${ISSUE_NUMBER}"
          else
            INSTANCE_ID=""
          fi

          # Export as outputs (with multiline values)
          {
            echo "base_sha=$BASE_SHA"
            echo "head_sha=$HEAD_SHA"
            echo "instance_id=$INSTANCE_ID"
          } >> "$GITHUB_OUTPUT"

          echo "PATCH<<'EOF'" >> $GITHUB_OUTPUT
          echo "$PATCH_CONTENT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "TEST_PATCH<<'EOF'" >> $GITHUB_OUTPUT
          echo "$TEST_PATCH_CONTENT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "test_args=$TEST_ARGS" >> $GITHUB_OUTPUT
          echo "java_version=$JAVA_VERSION" >> $GITHUB_OUTPUT

      # Step 3: Run dataset verifier script
      - name: Run dataset verifier
        id: run_verifier
        shell: bash
        env:
          REPO: ${{ github.repository }}
          FAIL_TO_PASS: ${{ needs.collect-process-tests.outputs.fail_to_pass }}
          PASS_TO_PASS: ${{ needs.collect-process-tests.outputs.pass_to_pass }}
          PATCH: ${{ steps.prepare_params.outputs.PATCH }}
          TEST_PATCH: ${{ steps.prepare_params.outputs.TEST_PATCH }}
          COMMIT: ${{ steps.prepare_params.outputs.base_sha }}
          TEST_ARGS: ${{ steps.prepare_params.outputs.test_args }}
          JAVA_VERSION: ${{ steps.prepare_params.outputs.java_version }}
          INSTANCE_ID: ${{ steps.prepare_params.outputs.instance_id }}
        run: |
          set -e
          chmod +x infrastructure/shared/.github/workflows/verify_java_dataset_instance.sh
          OUTPUT_FILE="$(mktemp)"
          infrastructure/shared/.github/workflows/verify_java_dataset_instance.sh \
            "$REPO" \
            "$COMMIT" \
            "$PATCH" \
            "$TEST_PATCH" \
            "$FAIL_TO_PASS" \
            "$PASS_TO_PASS" \
            "$TEST_ARGS" \
            "true" \
            "$JAVA_VERSION" \
            "$INSTANCE_ID" \
            false \
            true | tee "$OUTPUT_FILE"
          VERDICT="$(tail -n1 "$OUTPUT_FILE")"
          echo "verdict=$VERDICT" >> $GITHUB_OUTPUT
          if [[ "$VERDICT" == "✅" ]]; then
            echo "result=success" >> $GITHUB_OUTPUT
            echo "emoji=✅" >> $GITHUB_OUTPUT
            echo "reason=All checks passed" >> $GITHUB_OUTPUT
          else
            echo "result=failure" >> $GITHUB_OUTPUT
            echo "emoji=❌" >> $GITHUB_OUTPUT
            CLEAN_REASON="${VERDICT#❌ }"
            echo "reason=$CLEAN_REASON" >> $GITHUB_OUTPUT
          fi

      # Step 4: Update comment with final status from verifier
      - name: Update issue comment with final status
        if: ${{ always() && (github.event_name == 'push' || github.event_name == 'issue_comment') }}
        uses: actions/github-script@v7
        env:
          COMMENT_ID: ${{ steps.create_comment.outputs.comment_id }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          WORKFLOW_NAME: ${{ github.workflow }}
          RESULT: ${{ steps.run_verifier.outputs.result }}
          EMOJI: ${{ steps.run_verifier.outputs.emoji }}
          REASON: ${{ steps.run_verifier.outputs.reason }}
          FAIL_TO_PASS: ${{ needs.collect-process-tests.outputs.fail_to_pass }}
          PASS_TO_PASS: ${{ needs.collect-process-tests.outputs.pass_to_pass }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            if (!process.env.COMMENT_ID) { core.info('No comment to update.'); return; }
            let bodyContent = '';
            if (!process.env.COMMENT_ID){
              if (process.env.FAIL_TO_PASS && process.env.FAIL_TO_PASS !== '[]') {
                const failToPassArray = JSON.parse(process.env.FAIL_TO_PASS);
                const failToPassString = failToPassArray.join(', ');
                bodyContent += `FAIL_TO_PASS: ${failToPassString}\n`;
              }
              if (process.env.PASS_TO_PASS && process.env.PASS_TO_PASS !== '[]') {
                const passToPassArray = JSON.parse(process.env.PASS_TO_PASS);
                const passToPassString = passToPassArray.join(', ');
                bodyContent += `PASS_TO_PASS: ${passToPassString}\n`;
              }
            }
            const emoji = process.env.EMOJI || '🟡';
            const reason = process.env.REASON ? `: ${process.env.REASON}` : '';
            bodyContent += `\n${emoji} **[${process.env.WORKFLOW_NAME}](${process.env.RUN_URL})** finished${reason}`;
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: Number(process.env.COMMENT_ID),
              body: bodyContent
            });